# SQL-First E-commerce Application Structure
```
ecommerce-app/
│
├── server/
│   ├── scripts/
│   │   └──db-cli.js
│   ├── src/
│   │   ├── config/
│   │   │   ├── db.js           # Database connection
│   │   │   └── environment.js  # Environment variables
│   │   │
│   │   ├── db/
│   │   │   ├── schema/         # Database schema files
│   │   │   │   ├── tables.sql
│   │   │   │   ├── indexes.sql
│   │   │   │   └── constraints.sql
│   │   │   │
│   │   │   ├── queries/        # Organized SQL queries
│   │   │   │   ├── users.js    # User-related queries
│   │   │   │   ├── products.js # Product-related queries
│   │   │   │   ├── orders.js   # Order-related queries
│   │   │   │   ├── analytics.js # Analytics queries
│   │   │   │   └── search.js   # Search functionality
│   │   │   │
│   │   │   └── migrations/     # Database migrations
│   │   │       ├── 001_initial_setup.sql
│   │   │       ├── 002_add_indexes.sql
│   │   │       ├── 003_add_constraints.sql
│   │   │       └── migration-manager.js
│   │   │
│   │   ├── controllers/        # Request handlers
│   │   │   ├── userController.js
│   │   │   ├── productController.js
│   │   │   ├── orderController.js
│   │   │   └── analyticsController.js
│   │   │
│   │   ├── routes/             # API routes
│   │   │   ├── userRoutes.js
│   │   │   ├── productRoutes.js
│   │   │   ├── orderRoutes.js
│   │   │   └── analyticsRoutes.js
│   │   │
│   │   ├── middleware/         # Request middleware
│   │   │   ├── auth.js
│   │   │   ├── validation.js
│   │   │   └── errorHandler.js
│   │   │
│   │   ├── utils/              # Helper functions
│   │   │   ├── sqlBuilder.js   # Dynamic SQL query builder
│   │   │   ├── validator.js    # Input validation
│   │   │   ├── logger.js       # SQL logging
│   │   │   └── error.js        # Error formatting
│   │   │
│   │   └── server.js           # Entry point
│   │
│   ├── package.json
│   └── .env                    # Environment variables
│
├── README.md
└── docker-compose.yml         # Docker setup for PostgreSQL
```
## Tech Stack
- Node.js with Express
- PostgreSQL (raw SQL queries)
- pg (Node PostgreSQL driver)
- Redis (for caching)
- JWT for authentication

## Database Schema Overview
- Users (customers, admins, etc.)
- Products (catalog items)
- Categories (product organization)
- Orders (purchase transactions)
- Order_Items (items in each order)
- Inventory (stock management)
- Reviews (product reviews)
- Wishlists
- Shopping_Carts
- Payment_Transactions

## SQL Topic Implementation
1. **CRUD Operations**: Implemented across all entities
2. **JOINs**: Used in order retrieval, product listings, etc.
3. **Aggregation**: Used in analytics, reporting
4. **Subqueries**: Used in inventory management, user analytics
5. **Window Functions**: Used in sales ranking, time-series analysis
6. **Indexes**: Created for performance optimization
7. **Transactions**: Used in order processing, inventory updates

## Development Approach
1. Define database schema with proper relations
2. Create comprehensive SQL queries for all operations
3. Implement API endpoints with raw SQL
4. Add authentication and authorization
5. Implement error handling and validation
6. Optimize queries for performance

-- tables.sql: Database schema for e-commerce application
-- Enable UUID generation

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Users Table
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    email_verified BOOLEAN DEFAULT FALSE,
    address JSONB,  -- Structured address data
    role VARCHAR(20) CHECK (role IN ('customer', 'admin', 'seller')) DEFAULT 'customer',
    account_status VARCHAR(20) CHECK (account_status IN ('active', 'suspended', 'banned')) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE
);

CREATE TABLE user_tokens (
  token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL UNIQUE,
  type VARCHAR(50) NOT NULL CHECK (type IN ('email_verification', 'password_reset', 'api_token')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  used_at TIMESTAMP WITH TIME ZONE
);

-- 2. Categories Table
CREATE TABLE categories (
    category_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    parent_id UUID REFERENCES categories(category_id), -- Self-reference for hierarchical categories
    image_url VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 3. Products Table
CREATE TABLE products (
    product_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    sku VARCHAR(50) UNIQUE,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    compare_price DECIMAL(10, 2) CHECK (compare_price IS NULL OR compare_price >= price),
    cost_price DECIMAL(10, 2),
    category_id UUID REFERENCES categories(category_id),
    seller_id UUID REFERENCES users(user_id),
    brand VARCHAR(100),
    weight DECIMAL(8, 2),
    dimensions JSONB, -- Store height, width, length
    is_physical BOOLEAN DEFAULT TRUE, -- Physical vs digital product
    is_active BOOLEAN DEFAULT TRUE,
    is_featured BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 4. Product Images Table
CREATE TABLE product_images (
    image_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    url VARCHAR(255) NOT NULL,
    alt_text VARCHAR(255),
    is_primary BOOLEAN DEFAULT FALSE,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 5. Product Attributes Table
CREATE TABLE product_attributes (
    attribute_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    value TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 6. Inventory Table
CREATE TABLE inventory (
    inventory_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
    reserved_quantity INTEGER NOT NULL DEFAULT 0 CHECK (reserved_quantity >= 0),
    warehouse_location VARCHAR(100),
    low_stock_threshold INTEGER DEFAULT 5,
    last_restock_date TIMESTAMP WITH TIME ZONE,
    next_restock_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 7. Shopping Cart Table
CREATE TABLE shopping_carts (
    cart_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id) ON DELETE CASCADE,
    session_id VARCHAR(100), -- For non-logged in users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE,
    
    -- Ensure either user_id or session_id is provided
    CONSTRAINT cart_user_or_session CHECK (
        (user_id IS NOT NULL AND session_id IS NULL) OR
        (user_id IS NULL AND session_id IS NOT NULL)
    )
);

-- 8. Cart Items Table
CREATE TABLE cart_items (
    cart_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cart_id UUID NOT NULL REFERENCES shopping_carts(cart_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    custom_attributes JSONB -- Store custom options, gift messages, etc.
);

-- 9. Orders Table
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id),
    order_number VARCHAR(50) UNIQUE NOT NULL,
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'processing', 'on_hold',
            'completed', 'cancelled', 'refunded',
            'failed', 'shipped', 'delivered'
        )
    ) DEFAULT 'pending',
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    shipping_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (shipping_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),
    shipping_address JSONB NOT NULL,
    billing_address JSONB NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    payment_status VARCHAR(30) CHECK (
        payment_status IN (
            'pending', 'authorized', 'paid',
            'partially_refunded', 'refunded', 'failed'
        )
    ) DEFAULT 'pending',
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- 10. Order Items Table
CREATE TABLE order_items (
    order_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    name VARCHAR(255) NOT NULL, -- Store product name at time of purchase
    sku VARCHAR(50) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10, 2) NOT NULL CHECK (unit_price >= 0),
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total DECIMAL(10, 2) NOT NULL CHECK (total >= 0),
    product_data JSONB, -- Store snapshot of product data
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 11. Payments Table
CREATE TABLE payments (
    payment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id),
    amount DECIMAL(10, 2) NOT NULL CHECK (amount >= 0),
    payment_method VARCHAR(50) NOT NULL,
    payment_provider VARCHAR(50) NOT NULL,
    transaction_id VARCHAR(255),
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'authorized', 'completed',
            'failed', 'refunded', 'partially_refunded'
        )
    ) DEFAULT 'pending',
    provider_response JSONB, -- Store provider's response
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 12. Order History Table
CREATE TABLE order_history (
    history_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    status VARCHAR(30) NOT NULL,
    comment TEXT,
    created_by UUID REFERENCES users(user_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 13. Product Reviews Table
CREATE TABLE product_reviews (
    review_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(user_id),
    rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
    title VARCHAR(255),
    content TEXT,
    is_verified_purchase BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) CHECK (status IN ('pending', 'approved', 'rejected')) DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 14. Wishlist Table
CREATE TABLE wishlists (
    wishlist_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    name VARCHAR(100) DEFAULT 'Default',
    is_public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 15. Wishlist Items Table
CREATE TABLE wishlist_items (
    wishlist_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    wishlist_id UUID NOT NULL REFERENCES wishlists(wishlist_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    notes TEXT
);

-- 16. Discounts Table
CREATE TABLE discounts (
    discount_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE,
    type VARCHAR(20) CHECK (type IN ('percentage', 'fixed_amount', 'free_shipping')) NOT NULL,
    value DECIMAL(10, 2) CHECK (value >= 0),
    min_purchase_amount DECIMAL(10, 2) CHECK (min_purchase_amount >= 0),
    max_discount_amount DECIMAL(10, 2) CHECK (max_discount_amount >= 0),
    starts_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ends_at TIMESTAMP WITH TIME ZONE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    usage_limit INTEGER,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 17. Discount Products Table (which products the discount applies to)
CREATE TABLE discount_products (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, product_id)
);

-- 18. Discount Categories Table (which categories the discount applies to)
CREATE TABLE discount_categories (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(category_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, category_id)
);

-- 19. User Addresses Table
CREATE TABLE user_addresses (
    address_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    is_default BOOLEAN DEFAULT FALSE,
    address_type VARCHAR(20) CHECK (address_type IN ('billing', 'shipping', 'both')) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    address_line1 VARCHAR(255) NOT NULL,
    address_line2 VARCHAR(255),
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 20. Notification Templates Table
CREATE TABLE notification_templates (
    template_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    subject VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(50) CHECK (type IN ('email', 'sms', 'push')) NOT NULL,
    variables JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 21. User Notifications Table
CREATE TABLE user_notifications (
    notification_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(template_id),
    data JSONB, -- Data used to fill template variables
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP WITH TIME ZONE
);

-- 22. API tokens for developers
CREATE TABLE api_tokens (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    permissions JSONB,
    last_used_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 23. Product Tags Table
CREATE TABLE tags (
    tag_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL UNIQUE,
    slug VARCHAR(50) NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 24. Product-Tag Relation Table
CREATE TABLE product_tags (
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(tag_id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, tag_id)
);


-- indexes.sql: Optimized indexes for e-commerce database

-- Users Table Indexes
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_account_status ON users(account_status);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Categories Table Indexes
CREATE INDEX idx_categories_parent_id ON categories(parent_id);
CREATE INDEX idx_categories_is_active ON categories(is_active);

-- Products Table Indexes
CREATE INDEX idx_products_name ON products(name);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_seller_id ON products(seller_id);
CREATE INDEX idx_products_is_active ON products(is_active);
CREATE INDEX idx_products_is_featured ON products(is_featured);
CREATE INDEX idx_products_price ON products(price);
CREATE INDEX idx_products_created_at ON products(created_at);
-- This index helps with price range searches, a common filter in e-commerce
CREATE INDEX idx_products_price_active_category ON products(price, is_active, category_id);

-- Product Images Table Indexes
CREATE INDEX idx_product_images_product_id ON product_images(product_id);
CREATE INDEX idx_product_images_is_primary ON product_images(is_primary);




// server/src/config/db.js DONE

// server/src/config/environment.js   DONE

// server/src/utils/logger.js DONE

// server/src/utils/sqlBuilder.js  DONE
/**
 * SQL Query Builder
 * Provides utilities for dynamically building SQL queries
 */
class SqlBuilder {
  /**
   * Build ORDER BY clause from sort parameters
   * @param {Object|Array|string} sort - Sort configuration
   * @param {string} defaultSort - Default sort field and direction
   * @returns {string} ORDER BY clause
   */
  static buildOrderByClause(sort, defaultSort = 'created_at DESC') {
    if (!sort) {
      return `ORDER BY ${defaultSort}`;
    }

    let sortFields = [];

    if (typeof sort === 'string') {
      // Simple string sorting e.g. 'price ASC'
      sortFields.push(sort);
    } else if (Array.isArray(sort)) {
      // Array of sort fields e.g. ['price ASC', 'name DESC']
      sortFields = sort;
    } else if (typeof sort === 'object') {
      // Object with field:direction pairs e.g. { price: 'ASC', name: 'DESC' }
      sortFields = Object.entries(sort).map(([field, direction]) => 
        `${field} ${direction.toUpperCase()}`
      );
    }

    return sortFields.length > 0
      ? `ORDER BY ${sortFields.join(', ')}`
      : `ORDER BY ${defaultSort}`;
  }

  /**
   * Build LIMIT and OFFSET clause for pagination
   * @param {number} page - Page number (1-based indexing)
   * @param {number} limit - Number of records per page
   * @returns {Object} Object containing limit, offset and pagination info
   */
  static buildPaginationClause(page = 1, limit = 20) {
    const pageNum = Math.max(1, parseInt(page, 10));
    const limitNum = Math.max(1, parseInt(limit, 10));
    const offset = (pageNum - 1) * limitNum;

    return {
      limitClause: `LIMIT ${limitNum} OFFSET ${offset}`,
      limit: limitNum,
      offset,
      page: pageNum
    };
  }

  /**
   * Build INSERT query
   * @param {string} table - Table name
   * @param {Object} data - Data to insert
   * @returns {Object} SQL query and parameters
   */
  static buildInsertQuery(table, data) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const placeholders = columns.map((_, index) => `$${index + 1}`).join(', ');
    
    const query = `
      INSERT INTO ${table} (${columns.join(', ')})
      VALUES (${placeholders})
      RETURNING *
    `;
    
    return { query, values };
  }

  /**
   * Build UPDATE query
   * @param {string} table - Table name
   * @param {Object} data - Data to update
   * @param {Object} where - Where conditions
   * @returns {Object} SQL query and parameters
   */
  static buildUpdateQuery(table, data, where) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const setClause = columns
      .map((col, index) => `${col} = $${index + 1}`)
      .join(', ');
    
    let paramCount = values.length;
    const whereConditions = [];
    const whereValues = [];
    
    for (const [key, value] of Object.entries(where)) {
      whereConditions.push(`${key} = $${++paramCount}`);
      whereValues.push(value);
    }
    
    const query = `
      UPDATE ${table}
      SET ${setClause}
      WHERE ${whereConditions.join(' AND ')}
      RETURNING *
    `;
    
    return { query, values: [...values, ...whereValues] };
  }

  /**
   * Build a query for fetching total count (for pagination)
   * @param {string} table - Table name
   * @param {Object} filters - Filter conditions
   * @returns {Object} SQL query and parameters
   */
  static buildCountQuery(table, filters = {}) {
    const { whereClause, params } = this.buildWhereClause(filters);
    
    const query = `
      SELECT COUNT(*) AS total
      FROM ${table}
      ${whereClause}
    `;
    
    return { query, params };
  }
}

module.exports = SqlBuilder;



// server/src/utils/error.js DONE
/**
 * Custom error classes for the application
 */

/**
 * Base application error
 */
 snippet
class AppError extends Error {
  constructor(message, statusCode = 500, errorCode = 'INTERNAL_ERROR') {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.isOperational = true; // Operational errors are expected and can be handled gracefully
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = {
  AppError,
  DatabaseError,
  NotFoundError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  ConflictError,
  RateLimitError,
  BadRequestError,
  ExternalServiceError,
  formatError
};


// server/src/db/queries/products.js
const db = require('../../config/db');
const SqlBuilder = require('../../utils/sqlBuilder');
const logger = require('../../utils/logger');
const { NotFoundError, DatabaseError } = require('../../utils/error');

/**
 * Product Queries
 */
const productQueries = {


  /**
   * Get trending products based on views, orders, and ratings
   * @param {Object} options - Filter options and limits
   * @returns {Promise<Array>} Trending products
   */
  getTrendingProducts: async ({ timeframe = '7 days', categoryId = null, limit = 10 }) => {
    try {
      
    } catch (error) {
      logger.error('Error fetching trending products', { error: error.message });
      throw new DatabaseError('Failed to fetch trending products');
    }
  },
}

/**
 * Product Controller
 * Handles all product-related operations
 */
const productQueries = require('../db/queries/products');
const searchQueries = require('../db/queries/search');
const { NotFoundError, ValidationError } = require('../utils/error');
const logger = require('../utils/logger');

/**
 * Get a list of products with pagination and filtering
 */
exports.listProducts = async (req, res, next) => {}



/**
 * Database Migration Manager
 * Handles executing and tracking migrations for the database
 */
const fs = require('fs').promises;
const path = require('path');
const db = require('../../config/db');
const logger = require('../../utils/logger');

class MigrationManager {
  /**
   * Initialize the migration manager
   */
  async init() {
    await this._createMigrationsTable();
  }

  /**
   * Create the migrations table if it doesn't exist
   * @private
   */
  async _createMigrationsTable() {
    try {
      const query = `
        CREATE TABLE IF NOT EXISTS migrations (
          id SERIAL PRIMARY KEY,
          name VARCHAR(255) NOT NULL UNIQUE,
          applied_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
      `;
      await db.query(query);
      logger.info('Migrations table checked/created');
    } catch (error) {
      logger.error('Failed to create migrations table', { error: error.message });
      throw error;
    }
  }

  /**
   * Get list of applied migrations
   * @returns {Promise<Array>} List of applied migration names
   * @private
   */
  async _getAppliedMigrations() {
    DONE
  }

  /**
   * Get list of available migration files
   * @returns {Promise<Array>} List of available migration file paths
   * @private
   */
  async _getAvailableMigrations() {
   DONE
  }

  /**
   * Record a migration as applied
   * @param {string} migrationName - Name of the migration file
   * @returns {Promise<void>}
   * @private
   */
  async _recordMigration(migrationName) {
   DONE
  }

  /**
   * Apply a migration
   * @param {string} migrationFile - Migration file name
   * @returns {Promise<void>}
   * @private
   */
  async _applyMigration(migrationFile) {
    DONE
  }

  /**
   * Run pending migrations
   * @returns {Promise<Array>} List of applied migrations
   */
  async runMigrations() {
   DONE
  }

  /**
   * Create a new migration file DONE
   * @param {string} name - Migration name
   * @returns {Promise<string>} Path to the created migration file
   */
  async createMigration(name) {
    try {
      const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
      const fileName = `${timestamp}_${name.toLowerCase().replace(/[^a-z0-9]/g, '_')}.sql`;
      const filePath = path.join(__dirname, 'migrations', fileName);
      
      const template = `-- Migration: ${name}
-- Created: ${new Date().toISOString()}

-- Write your SQL here

-- For example:
-- CREATE TABLE example (id SERIAL PRIMARY KEY, name VARCHAR(100));

-- To roll back:
-- Consider writing a down migration in a separate file if needed
`;
      
      await fs.writeFile(filePath, template, 'utf8');
      logger.info('Created migration file', { fileName });
      
      return filePath;
    } catch (error) {
      logger.error('Failed to create migration file', { error: error.message });
      throw error;
    }
  }
}

module.exports = new MigrationManager();





/**  DONE
 * Database Command Line Tool
 * Provides commands to initialize, migrate, seed, and reset the database
 */

snippet

const { program } = require('commander');
const { initializeDatabase } = require('../src/ecommerce/db/init');
const { runMigrations, revertMigration, createMigration } = require('../src/ecommerce/db/migrations/migrationManager');
const logger = require('../src/ecommerce/utils/logger');

// Configure commander
program
  .version('1.0.0')
  .description('E-commerce database management tool');

// Initialize database command
program
  .command('init')
  .description('Initialize database schema with tables, indexes, and constraints')
  .action(async () => {
    try {
      logger.info('Initializing database schema...');
      await initializeDatabase();
      logger.info('Database schema initialized successfully!');
    } catch (error) {
      logger.error('Failed to initialize database schema:', error);
      process.exit(1);
    }
  });



// server/src/config/db.js
const { Pool } = require('pg');
const logger = require('../utils/logger');
const { db: dbConfig } = require('./environment');

// Create PostgreSQL connection pool
const pool = new Pool({
  user: dbConfig.user,
  host: dbConfig.host,
  database: dbConfig.database,
  password: dbConfig.password,
  port: dbConfig.port,
  // Connection pool settings
  max: 20, // Maximum number of clients in the pool
  idleTimeoutMillis: 30000, // How long a client is allowed to remain idle before being closed
  connectionTimeoutMillis: 2000, // How long to wait for a connection
});

// Test the connection
pool.on('connect', () => {
  logger.info('Connected to PostgreSQL database');
});

pool.on('error', (err) => {
  logger.error('Unexpected error on idle client', err);
  process.exit(-1);
});

/**
 * Execute SQL query with optional parameters
 * @param {string} text - SQL query text
 * @param {Array} params - Query parameters
 * @param {Object} options - Additional options (transaction client, etc.)
 * @returns {Promise<Object>} Query result
 */
const query = async (text, params, options = {}) => {
  const start = Date.now();
  const client = options.client || pool;
  
  try {
    const result = await client.query(text, params);
    const duration = Date.now() - start;
    
    // Log the query for debugging/performance monitoring
    logger.debug('Executed query', { 
      text, 
      duration, 
      rows: result.rowCount,
      // Don't log params in production as they may contain sensitive data
      ...(process.env.NODE_ENV !== 'production' && { params })
    });
    
    return result;
  } catch (error) {
    logger.error('Database query error', { 
      text, 
      error: error.message,
      code: error.code
    });
    throw error;
  }
};