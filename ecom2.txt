# SQL-First E-commerce Application Structure
```
ecommerce-app/
│
├── server/
│   ├── src/
│   │   ├── config/
│   │   │   ├── db.js           # Database connection
│   │   │   └── environment.js  # Environment variables
│   │   │
│   │   ├── db/
│   │   │   ├── schema/         # Database schema files
│   │   │   │   ├── tables.sql
│   │   │   │   ├── indexes.sql
│   │   │   │   └── constraints.sql
│   │   │   │
│   │   │   ├── queries/        # Organized SQL queries
│   │   │   │   ├── users.js    # User-related queries
│   │   │   │   ├── products.js # Product-related queries
│   │   │   │   ├── orders.js   # Order-related queries
│   │   │   │   ├── analytics.js # Analytics queries
│   │   │   │   └── search.js   # Search functionality
│   │   │   │
│   │   │   └── migrations/     # Database migrations
│   │   │       ├── 001_initial_setup.sql
│   │   │       ├── 002_add_indexes.sql
│   │   │       └── 003_add_constraints.sql
│   │   │
│   │   ├── controllers/        # Request handlers
│   │   │   ├── userController.js
│   │   │   ├── productController.js
│   │   │   ├── orderController.js
│   │   │   └── analyticsController.js
│   │   │
│   │   ├── routes/             # API routes
│   │   │   ├── userRoutes.js
│   │   │   ├── productRoutes.js
│   │   │   ├── orderRoutes.js
│   │   │   └── analyticsRoutes.js
│   │   │
│   │   ├── middleware/         # Request middleware
│   │   │   ├── auth.js
│   │   │   ├── validation.js
│   │   │   └── errorHandler.js
│   │   │
│   │   ├── utils/              # Helper functions
│   │   │   ├── sqlBuilder.js   # Dynamic SQL query builder
│   │   │   ├── validator.js    # Input validation
│   │   │   ├── logger.js       # SQL logging
│   │   │   └── error.js        # Error formatting
│   │   │
│   │   └── server.js           # Entry point
│   │
│   ├── package.json
│   └── .env                    # Environment variables
│
├── README.md
└── docker-compose.yml         # Docker setup for PostgreSQL
```
## Tech Stack
- Node.js with Express
- PostgreSQL (raw SQL queries)
- pg (Node PostgreSQL driver)
- Redis (for caching)
- JWT for authentication

## Database Schema Overview
- Users (customers, admins, etc.)
- Products (catalog items)
- Categories (product organization)
- Orders (purchase transactions)
- Order_Items (items in each order)
- Inventory (stock management)
- Reviews (product reviews)
- Wishlists
- Shopping_Carts
- Payment_Transactions

## SQL Topic Implementation
1. **CRUD Operations**: Implemented across all entities
2. **JOINs**: Used in order retrieval, product listings, etc.
3. **Aggregation**: Used in analytics, reporting
4. **Subqueries**: Used in inventory management, user analytics
5. **Window Functions**: Used in sales ranking, time-series analysis
6. **Indexes**: Created for performance optimization
7. **Transactions**: Used in order processing, inventory updates

## Development Approach
1. Define database schema with proper relations
2. Create comprehensive SQL queries for all operations
3. Implement API endpoints with raw SQL
4. Add authentication and authorization
5. Implement error handling and validation
6. Optimize queries for performance

-- tables.sql: Database schema for e-commerce application
-- Enable UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Users Table
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    address JSONB,  -- Structured address data
    role VARCHAR(20) CHECK (role IN ('customer', 'admin', 'seller')) DEFAULT 'customer',
    account_status VARCHAR(20) CHECK (account_status IN ('active', 'suspended', 'banned')) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE
);

-- 2. Categories Table
CREATE TABLE categories (
    category_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    parent_id UUID REFERENCES categories(category_id), -- Self-reference for hierarchical categories
    image_url VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 3. Products Table
CREATE TABLE products (
    product_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    sku VARCHAR(50) UNIQUE,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    compare_price DECIMAL(10, 2) CHECK (compare_price IS NULL OR compare_price >= price),
    cost_price DECIMAL(10, 2),
    category_id UUID REFERENCES categories(category_id),
    seller_id UUID REFERENCES users(user_id),
    brand VARCHAR(100),
    weight DECIMAL(8, 2),
    dimensions JSONB, -- Store height, width, length
    is_physical BOOLEAN DEFAULT TRUE, -- Physical vs digital product
    is_active BOOLEAN DEFAULT TRUE,
    is_featured BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 4. Product Images Table
CREATE TABLE product_images (
    image_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    url VARCHAR(255) NOT NULL,
    alt_text VARCHAR(255),
    is_primary BOOLEAN DEFAULT FALSE,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 5. Product Attributes Table
CREATE TABLE product_attributes (
    attribute_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    value TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 6. Inventory Table
CREATE TABLE inventory (
    inventory_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
    reserved_quantity INTEGER NOT NULL DEFAULT 0 CHECK (reserved_quantity >= 0),
    warehouse_location VARCHAR(100),
    low_stock_threshold INTEGER DEFAULT 5,
    last_restock_date TIMESTAMP WITH TIME ZONE,
    next_restock_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 7. Shopping Cart Table
CREATE TABLE shopping_carts (
    cart_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id) ON DELETE CASCADE,
    session_id VARCHAR(100), -- For non-logged in users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE,
    
    -- Ensure either user_id or session_id is provided
    CONSTRAINT cart_user_or_session CHECK (
        (user_id IS NOT NULL AND session_id IS NULL) OR
        (user_id IS NULL AND session_id IS NOT NULL)
    )
);

-- 8. Cart Items Table
CREATE TABLE cart_items (
    cart_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cart_id UUID NOT NULL REFERENCES shopping_carts(cart_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    custom_attributes JSONB -- Store custom options, gift messages, etc.
);

-- 9. Orders Table
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id),
    order_number VARCHAR(50) UNIQUE NOT NULL,
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'processing', 'on_hold',
            'completed', 'cancelled', 'refunded',
            'failed', 'shipped', 'delivered'
        )
    ) DEFAULT 'pending',
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    shipping_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (shipping_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),
    shipping_address JSONB NOT NULL,
    billing_address JSONB NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    payment_status VARCHAR(30) CHECK (
        payment_status IN (
            'pending', 'authorized', 'paid',
            'partially_refunded', 'refunded', 'failed'
        )
    ) DEFAULT 'pending',
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- 10. Order Items Table
CREATE TABLE order_items (
    order_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    name VARCHAR(255) NOT NULL, -- Store product name at time of purchase
    sku VARCHAR(50) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10, 2) NOT NULL CHECK (unit_price >= 0),
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total DECIMAL(10, 2) NOT NULL CHECK (total >= 0),
    product_data JSONB, -- Store snapshot of product data
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 11. Payments Table
CREATE TABLE payments (
    payment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id),
    amount DECIMAL(10, 2) NOT NULL CHECK (amount >= 0),
    payment_method VARCHAR(50) NOT NULL,
    payment_provider VARCHAR(50) NOT NULL,
    transaction_id VARCHAR(255),
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'authorized', 'completed',
            'failed', 'refunded', 'partially_refunded'
        )
    ) DEFAULT 'pending',
    provider_response JSONB, -- Store provider's response
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 12. Order History Table
CREATE TABLE order_history (
    history_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    status VARCHAR(30) NOT NULL,
    comment TEXT,
    created_by UUID REFERENCES users(user_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 13. Product Reviews Table
CREATE TABLE product_reviews (
    review_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(user_id),
    rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
    title VARCHAR(255),
    content TEXT,
    is_verified_purchase BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) CHECK (status IN ('pending', 'approved', 'rejected')) DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 14. Wishlist Table
CREATE TABLE wishlists (
    wishlist_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    name VARCHAR(100) DEFAULT 'Default',
    is_public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 15. Wishlist Items Table
CREATE TABLE wishlist_items (
    wishlist_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    wishlist_id UUID NOT NULL REFERENCES wishlists(wishlist_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    notes TEXT
);

-- 16. Discounts Table
CREATE TABLE discounts (
    discount_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE,
    type VARCHAR(20) CHECK (type IN ('percentage', 'fixed_amount', 'free_shipping')) NOT NULL,
    value DECIMAL(10, 2) CHECK (value >= 0),
    min_purchase_amount DECIMAL(10, 2) CHECK (min_purchase_amount >= 0),
    max_discount_amount DECIMAL(10, 2) CHECK (max_discount_amount >= 0),
    starts_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ends_at TIMESTAMP WITH TIME ZONE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    usage_limit INTEGER,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 17. Discount Products Table (which products the discount applies to)
CREATE TABLE discount_products (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, product_id)
);

-- 18. Discount Categories Table (which categories the discount applies to)
CREATE TABLE discount_categories (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(category_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, category_id)
);

-- 19. User Addresses Table
CREATE TABLE user_addresses (
    address_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    is_default BOOLEAN DEFAULT FALSE,
    address_type VARCHAR(20) CHECK (address_type IN ('billing', 'shipping', 'both')) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    address_line1 VARCHAR(255) NOT NULL,
    address_line2 VARCHAR(255),
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 20. Notification Templates Table
CREATE TABLE notification_templates (
    template_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    subject VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(50) CHECK (type IN ('email', 'sms', 'push')) NOT NULL,
    variables JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 21. User Notifications Table
CREATE TABLE user_notifications (
    notification_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(template_id),
    data JSONB, -- Data used to fill template variables
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP WITH TIME ZONE
);

-- 22. API tokens for developers
CREATE TABLE api_tokens (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    permissions JSONB,
    last_used_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 23. Product Tags Table
CREATE TABLE tags (
    tag_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL UNIQUE,
    slug VARCHAR(50) NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 24. Product-Tag Relation Table
CREATE TABLE product_tags (
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(tag_id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, tag_id)
);


-- indexes.sql: Optimized indexes for e-commerce database

-- Users Table Indexes
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_account_status ON users(account_status);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Categories Table Indexes
CREATE INDEX idx_categories_parent_id ON categories(parent_id);
CREATE INDEX idx_categories_is_active ON categories(is_active);

-- Products Table Indexes
CREATE INDEX idx_products_name ON products(name);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_seller_id ON products(seller_id);
CREATE INDEX idx_products_is_active ON products(is_active);
CREATE INDEX idx_products_is_featured ON products(is_featured);
CREATE INDEX idx_products_price ON products(price);
CREATE INDEX idx_products_created_at ON products(created_at);
-- This index helps with price range searches, a common filter in e-commerce
CREATE INDEX idx_products_price_active_category ON products(price, is_active, category_id);

-- Product Images Table Indexes
CREATE INDEX idx_product_images_product_id ON product_images(product_id);
CREATE INDEX idx_product_images_is_primary ON product_images(is_primary);

-- Product Attributes Table Indexes
CREATE INDEX idx_product_attributes_product_id ON product_attributes(product_id);
CREATE INDEX idx_product_attributes_name ON product_attributes(name);
CREATE INDEX idx_product_attributes_name_value ON product_attributes(name, value);

-- Inventory Table Indexes
CREATE INDEX idx_inventory_product_id ON inventory(product_id);
CREATE INDEX idx_inventory_quantity ON inventory(quantity);
-- Index for low stock alerts
CREATE INDEX idx_inventory_low_stock ON inventory(quantity) WHERE quantity <= low_stock_threshold;

-- Shopping Cart Table Indexes
CREATE INDEX idx_shopping_carts_user_id ON shopping_carts(user_id);
CREATE INDEX idx_shopping_carts_session_id ON shopping_carts(session_id);
CREATE INDEX idx_shopping_carts_created_at ON shopping_carts(created_at);
CREATE INDEX idx_shopping_carts_expires_at ON shopping_carts(expires_at);

-- Cart Items Table Indexes
CREATE INDEX idx_cart_items_cart_id ON cart_items(cart_id);
CREATE INDEX idx_cart_items_product_id ON cart_items(product_id);

-- Orders Table Indexes
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_order_number ON orders(order_number);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_completed_at ON orders(completed_at);
-- Composite index for order analytics
CREATE INDEX idx_orders_status_created_at ON orders(status, created_at);

-- Order Items Table Indexes
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);

-- Payments Table Indexes
CREATE INDEX idx_payments_order_id ON payments(order_id);
CREATE INDEX idx_payments_transaction_id ON payments(transaction_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_payments_created_at ON payments(created_at);

-- Order History Table Indexes
CREATE INDEX idx_order_history_order_id ON order_history(order_id);
CREATE INDEX idx_order_history_created_at ON order_history(created_at);

-- Product Reviews Table Indexes
CREATE INDEX idx_product_reviews_product_id ON product_reviews(product_id);
CREATE INDEX idx_product_reviews_user_id ON product_reviews(user_id);
CREATE INDEX idx_product_reviews_rating ON product_reviews(rating);
CREATE INDEX idx_product_reviews_status ON product_reviews(status);
-- Index for finding verified purchase reviews
CREATE INDEX idx_product_reviews_verified_purchase ON product_reviews(is_verified_purchase) WHERE is_verified_purchase = TRUE;

-- Wishlist Table Indexes
CREATE INDEX idx_wishlists_user_id ON wishlists(user_id);

-- Wishlist Items Table Indexes
CREATE INDEX idx_wishlist_items_wishlist_id ON wishlist_items(wishlist_id);
CREATE INDEX idx_wishlist_items_product_id ON wishlist_items(product_id);

-- Discounts Table Indexes
CREATE INDEX idx_discounts_code ON discounts(code);
CREATE INDEX idx_discounts_is_active ON discounts(is_active);
CREATE INDEX idx_discounts_date_range ON discounts(starts_at, ends_at);
-- This index helps find valid discounts quickly
CREATE INDEX idx_discounts_active_dates ON discounts(is_active, starts_at, ends_at);

-- User Addresses Table Indexes
CREATE INDEX idx_user_addresses_user_id ON user_addresses(user_id);
CREATE INDEX idx_user_addresses_is_default ON user_addresses(is_default);

-- User Notifications Table Indexes
CREATE INDEX idx_user_notifications_user_id ON user_notifications(user_id);
CREATE INDEX idx_user_notifications_is_read ON user_notifications(is_read);
CREATE INDEX idx_user_notifications_created_at ON user_notifications(created_at);

-- API Tokens Table Indexes
CREATE INDEX idx_api_tokens_user_id ON api_tokens(user_id);
CREATE INDEX idx_api_tokens_token ON api_tokens(token);
CREATE INDEX idx_api_tokens_expires_at ON api_tokens(expires_at);

-- Tags Table Indexes
CREATE INDEX idx_tags_name ON tags(name);
CREATE INDEX idx_tags_slug ON tags(slug);

-- Partial Index for Fast Access to Active Products
CREATE INDEX idx_active_products ON products(product_id) WHERE is_active = TRUE;

-- Full Text Search for Products
-- Enable the extension if not already enabled
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- Create GIN index for full-text search on product names and descriptions
CREATE INDEX idx_products_name_trgm ON products USING GIN (name gin_trgm_ops);
CREATE INDEX idx_products_description_trgm ON products USING GIN (description gin_trgm_ops);

-- Create a GIN index for JSONB fields
CREATE INDEX idx_product_attributes_jsonb ON product_attributes USING GIN (value jsonb_path_ops) WHERE jsonb_typeof(value) = 'object';
CREATE INDEX idx_order_items_product_data ON order_items USING GIN (product_data);


// server/src/config/db.js DONE

// server/src/config/environment.js   DONE

// server/src/utils/logger.js DONE

// server/src/utils/sqlBuilder.js 
/**
 * SQL Query Builder
 * Provides utilities for dynamically building SQL queries
 */
class SqlBuilder {
  /**
   * Create a WHERE clause from filter conditions
   * @param {Object} filters - Key-value pairs of filter conditions
   * @param {number} [startParamIndex=1] - Starting index for parameterized queries
   * @returns {Object} Object containing where clause and parameters
   */
  static buildWhereClause(filters, startParamIndex = 1) {
    if (!filters || Object.keys(filters).length === 0) {
      return { whereClause: '', params: [] };
    }

    const conditions = [];
    const params = [];
    let paramIndex = startParamIndex;

    for (const [key, value] of Object.entries(filters)) {
      // Skip null or undefined values
      if (value === null || value === undefined) continue;

      // Handle special operators like IN, BETWEEN, etc.
      if (typeof value === 'object' && !Array.isArray(value)) {
        const { operator, value: operatorValue } = value;
        
        if (operator && operatorValue !== null && operatorValue !== undefined) {
          switch (operator.toUpperCase()) {
            case 'IN':
              if (Array.isArray(operatorValue) && operatorValue.length > 0) {
                const placeholders = operatorValue.map(() => `$${paramIndex++}`).join(', ');
                conditions.push(`${key} IN (${placeholders})`);
                params.push(...operatorValue);
              }
              break;
            case 'BETWEEN':
              if (Array.isArray(operatorValue) && operatorValue.length === 2) {
                conditions.push(`${key} BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
                params.push(operatorValue[0], operatorValue[1]);
                paramIndex += 2;
              }
              break;
            case 'LIKE':
            case 'ILIKE':
              conditions.push(`${key} ${operator} $${paramIndex++}`);
              params.push(`%${operatorValue}%`);
              break;
            case '>':
            case '>=':
            case '<':
            case '<=':
            case '!=':
              conditions.push(`${key} ${operator} $${paramIndex++}`);
              params.push(operatorValue);
              break;
            case 'IS NULL':
              conditions.push(`${key} IS NULL`);
              break;
            case 'IS NOT NULL':
              conditions.push(`${key} IS NOT NULL`);
              break;
            default:
              conditions.push(`${key} = $${paramIndex++}`);
              params.push(operatorValue);
          }
        }
      } else if (Array.isArray(value)) {
        // Handle array values as IN conditions
        if (value.length > 0) {
          const placeholders = value.map(() => `$${paramIndex++}`).join(', ');
          conditions.push(`${key} IN (${placeholders})`);
          params.push(...value);
        }
      } else {
        // Handle simple equality
        conditions.push(`${key} = $${paramIndex++}`);
        params.push(value);
      }
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    return { whereClause, params };
  }

  /**
   * Build ORDER BY clause from sort parameters
   * @param {Object|Array|string} sort - Sort configuration
   * @param {string} defaultSort - Default sort field and direction
   * @returns {string} ORDER BY clause
   */
  static buildOrderByClause(sort, defaultSort = 'created_at DESC') {
    if (!sort) {
      return `ORDER BY ${defaultSort}`;
    }

    let sortFields = [];

    if (typeof sort === 'string') {
      // Simple string sorting e.g. 'price ASC'
      sortFields.push(sort);
    } else if (Array.isArray(sort)) {
      // Array of sort fields e.g. ['price ASC', 'name DESC']
      sortFields = sort;
    } else if (typeof sort === 'object') {
      // Object with field:direction pairs e.g. { price: 'ASC', name: 'DESC' }
      sortFields = Object.entries(sort).map(([field, direction]) => 
        `${field} ${direction.toUpperCase()}`
      );
    }

    return sortFields.length > 0
      ? `ORDER BY ${sortFields.join(', ')}`
      : `ORDER BY ${defaultSort}`;
  }

  /**
   * Build LIMIT and OFFSET clause for pagination
   * @param {number} page - Page number (1-based indexing)
   * @param {number} limit - Number of records per page
   * @returns {Object} Object containing limit, offset and pagination info
   */
  static buildPaginationClause(page = 1, limit = 20) {
    const pageNum = Math.max(1, parseInt(page, 10));
    const limitNum = Math.max(1, parseInt(limit, 10));
    const offset = (pageNum - 1) * limitNum;

    return {
      limitClause: `LIMIT ${limitNum} OFFSET ${offset}`,
      limit: limitNum,
      offset,
      page: pageNum
    };
  }

  /**
   * Build INSERT query
   * @param {string} table - Table name
   * @param {Object} data - Data to insert
   * @returns {Object} SQL query and parameters
   */
  static buildInsertQuery(table, data) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const placeholders = columns.map((_, index) => `$${index + 1}`).join(', ');
    
    const query = `
      INSERT INTO ${table} (${columns.join(', ')})
      VALUES (${placeholders})
      RETURNING *
    `;
    
    return { query, values };
  }

  /**
   * Build UPDATE query
   * @param {string} table - Table name
   * @param {Object} data - Data to update
   * @param {Object} where - Where conditions
   * @returns {Object} SQL query and parameters
   */
  static buildUpdateQuery(table, data, where) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const setClause = columns
      .map((col, index) => `${col} = $${index + 1}`)
      .join(', ');
    
    let paramCount = values.length;
    const whereConditions = [];
    const whereValues = [];
    
    for (const [key, value] of Object.entries(where)) {
      whereConditions.push(`${key} = $${++paramCount}`);
      whereValues.push(value);
    }
    
    const query = `
      UPDATE ${table}
      SET ${setClause}
      WHERE ${whereConditions.join(' AND ')}
      RETURNING *
    `;
    
    return { query, values: [...values, ...whereValues] };
  }

  /**
   * Build a SELECT query
   * @param {string} table - Table name
   * @param {Array} columns - Columns to select
   * @param {Object} filters - Filter conditions
   * @param {Object} options - Additional options (sort, pagination)
   * @returns {Object} SQL query and parameters
   */
  static buildSelectQuery(table, columns = ['*'], filters = {}, options = {}) {
    const columnsStr = Array.isArray(columns) ? columns.join(', ') : columns;
    const { whereClause, params } = this.buildWhereClause(filters);
    
    const orderBy = options.sort
      ? this.buildOrderByClause(options.sort)
      : '';
    
    const pagination = options.pagination
      ? this.buildPaginationClause(options.pagination.page, options.pagination.limit)
      : { limitClause: '' };
    
    const query = `
      SELECT ${columnsStr}
      FROM ${table}
      ${whereClause}
      ${orderBy}
      ${pagination.limitClause}
    `;
    
    return { 
      query, 
      params, 
      pagination: options.pagination ? pagination : null 
    };
  }

  /**
   * Build a query for fetching total count (for pagination)
   * @param {string} table - Table name
   * @param {Object} filters - Filter conditions
   * @returns {Object} SQL query and parameters
   */
  static buildCountQuery(table, filters = {}) {
    const { whereClause, params } = this.buildWhereClause(filters);
    
    const query = `
      SELECT COUNT(*) AS total
      FROM ${table}
      ${whereClause}
    `;
    
    return { query, params };
  }

  /**
   * Generate a dynamically parameterized IN clause
   * @param {Array} items - Array of items for the IN clause
   * @param {number} startIndex - Starting parameter index
   * @returns {Object} parameterized IN clause and updated index
   */
  static generateInClause(items, startIndex = 1) {
    if (!items || items.length === 0) {
      return { inClause: '(NULL)', params: [], nextIndex: startIndex };
    }

    const placeholders = [];
    const params = [];
    let paramIndex = startIndex;

    for (const item of items) {
      placeholders.push(`$${paramIndex++}`);
      params.push(item);
    }

    return {
      inClause: `(${placeholders.join(', ')})`,
      params,
      nextIndex: paramIndex
    };
  }

  /**
   * Generate a dynamically parameterized VALUES clause for multi-row insert
   * @param {Array} items - Array of objects to insert
   * @param {Array} columns - Column names
   * @returns {Object} parameterized VALUES clause and parameters
   */
  static generateBulkInsertClause(items, columns) {
    if (!items || items.length === 0 || !columns || columns.length === 0) {
      return { valuesClause: '', params: [] };
    }

    const params = [];
    let paramIndex = 1;
    const valueRows = [];

    for (const item of items) {
      const rowPlaceholders = [];
      for (const column of columns) {
        rowPlaceholders.push(`$${paramIndex++}`);
        params.push(item[column] ?? null);
      }
      valueRows.push(`(${rowPlaceholders.join(', ')})`);
    }

    return {
      valuesClause: valueRows.join(',\n'),
      params
    };
  }

  /**
   * Build JSON/JSONB query conditions
   * @param {string} column - JSON column name
   * @param {string} path - JSON path
   * @param {*} value - Value to compare against
   * @param {string} [operator='='] - Comparison operator
   * @returns {Object} SQL fragment and value
   */
  static jsonCondition(column, path, value, operator = '=') {
    // For PostgreSQL JSONB operations
    const pathParts = path.split('.');
    let sqlFragment;
    
    if (pathParts.length === 1) {
      // Simple key access
      sqlFragment = `${column}->>'${pathParts[0]}' ${operator} $%i`;
    } else {
      // Nested key access
      const lastKey = pathParts.pop();
      const jsonPath = pathParts.map(part => `'${part}'`).join('->');
      sqlFragment = `${column}->${jsonPath}->>'${lastKey}' ${operator} $%i`;
    }
    
    return { sqlFragment, value };
  }
}

module.exports = SqlBuilder;



// server/src/utils/error.js DONE
/**
 * Custom error classes for the application
 */

/**
 * Base application error
 */
 snippet
class AppError extends Error {
  constructor(message, statusCode = 500, errorCode = 'INTERNAL_ERROR') {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.isOperational = true; // Operational errors are expected and can be handled gracefully
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = {
  AppError,
  DatabaseError,
  NotFoundError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  ConflictError,
  RateLimitError,
  BadRequestError,
  ExternalServiceError,
  formatError
};



// server/src/db/queries/products.js DONE
snippet
const db = require('../../config/db');
const SqlBuilder = require('../../utils/sqlBuilder');
const logger = require('../../utils/logger');
const { NotFoundError, DatabaseError } = require('../../utils/error');

/**
 * Product Queries
 */
 Snippets
const productQueries = {  
  /**
   * Get related products based on shared categories, tags, and attributes
   * @param {string} productId - Product ID
   * @param {number} limit - Number of related products to return
   * @returns {Promise<Array>} Related products
   */
  getRelatedProducts: async (productId, limit = 6) => {
    try {
      const query = `
        WITH product_info AS (
          SELECT 
            category_id,
            (
              SELECT ARRAY_AGG(tag_id) 
              FROM product_tags 
              WHERE product_id = $1
            ) AS tag_ids,
            (
              SELECT ARRAY_AGG(name) 
              FROM product_attributes 
              WHERE product_id = $1
            ) AS attribute_names
        FROM 
          products
        WHERE 
          product_id = $1
        ),
        related_score AS (
          SELECT 
            p.product_id,
            p.name,
            p.price,
            p.brand,
            (
              SELECT url 
              FROM product_images 
              WHERE product_id = p.product_id AND is_primary = TRUE 
              LIMIT 1
            ) AS primary_image,
            CASE WHEN p.category_id = (SELECT category_id FROM product_info) THEN 3 ELSE 0 END +
            (
              SELECT COUNT(*) 
              FROM product_tags pt 
              WHERE pt.product_id = p.product_id 
                AND pt.tag_id = ANY((SELECT tag_ids FROM product_info))
            ) * 2 +
            (
              SELECT COUNT(*) 
              FROM product_attributes pa 
              WHERE pa.product_id = p.product_id 
                AND pa.name = ANY((SELECT attribute_names FROM product_info))
            ) AS relevance_score
          FROM 
            products p
          WHERE 
            p.product_id != $1
            AND p.is_active = TRUE
        )
        SELECT * FROM related_score
        WHERE relevance_score > 0
        ORDER BY relevance_score DESC, name
        LIMIT $2
      `;
      
      const result = await db.query(query, [productId, limit]);
      return result.rows;
    } catch (error) {
      logger.error('Error fetching related products', { error: error.message, productId });
      throw new DatabaseError('Failed to fetch related products');
    }
  },
}
module.exports = productQueries;

// server/src/db/queries/orders.js DONE
// server/src/db/queries/users.js DONE
// server/src/db/queries/analytics.js DONE
// server/src/controllers/products.js DONE
// server/src/controllers/orders.js DONE
// server/src/controllers/users.js DONE
// server/src/controllers/analytics.js DONE
// server/src/middlewares/auth.js DONE
// server/src/middlewares/errorHandler.js DONE
// server/src/middlewares/validation.js DONE
routes DONE
server.js DONE
Database Migration Manager  DONE



