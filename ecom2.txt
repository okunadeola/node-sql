# SQL-First E-commerce Application Structure
```
ecommerce-app/
│
├── server/
│   ├── src/
│   │   ├── config/
│   │   │   ├── db.js           # Database connection
│   │   │   └── environment.js  # Environment variables
│   │   │
│   │   ├── db/
│   │   │   ├── schema/         # Database schema files
│   │   │   │   ├── tables.sql
│   │   │   │   ├── indexes.sql
│   │   │   │   └── constraints.sql
│   │   │   │
│   │   │   ├── queries/        # Organized SQL queries
│   │   │   │   ├── users.js    # User-related queries
│   │   │   │   ├── products.js # Product-related queries
│   │   │   │   ├── orders.js   # Order-related queries
│   │   │   │   ├── analytics.js # Analytics queries
│   │   │   │   └── search.js   # Search functionality
│   │   │   │
│   │   │   └── migrations/     # Database migrations
│   │   │       ├── 001_initial_setup.sql
│   │   │       ├── 002_add_indexes.sql
│   │   │       └── 003_add_constraints.sql
│   │   │
│   │   ├── controllers/        # Request handlers
│   │   │   ├── userController.js
│   │   │   ├── productController.js
│   │   │   ├── orderController.js
│   │   │   └── analyticsController.js
│   │   │
│   │   ├── routes/             # API routes
│   │   │   ├── userRoutes.js
│   │   │   ├── productRoutes.js
│   │   │   ├── orderRoutes.js
│   │   │   └── analyticsRoutes.js
│   │   │
│   │   ├── middleware/         # Request middleware
│   │   │   ├── auth.js
│   │   │   ├── validation.js
│   │   │   └── errorHandler.js
│   │   │
│   │   ├── utils/              # Helper functions
│   │   │   ├── sqlBuilder.js   # Dynamic SQL query builder
│   │   │   ├── validator.js    # Input validation
│   │   │   ├── logger.js       # SQL logging
│   │   │   └── error.js        # Error formatting
│   │   │
│   │   └── server.js           # Entry point
│   │
│   ├── package.json
│   └── .env                    # Environment variables
│
├── README.md
└── docker-compose.yml         # Docker setup for PostgreSQL
```
## Tech Stack
- Node.js with Express
- PostgreSQL (raw SQL queries)
- pg (Node PostgreSQL driver)
- Redis (for caching)
- JWT for authentication

## Database Schema Overview
- Users (customers, admins, etc.)
- Products (catalog items)
- Categories (product organization)
- Orders (purchase transactions)
- Order_Items (items in each order)
- Inventory (stock management)
- Reviews (product reviews)
- Wishlists
- Shopping_Carts
- Payment_Transactions

## SQL Topic Implementation
1. **CRUD Operations**: Implemented across all entities
2. **JOINs**: Used in order retrieval, product listings, etc.
3. **Aggregation**: Used in analytics, reporting
4. **Subqueries**: Used in inventory management, user analytics
5. **Window Functions**: Used in sales ranking, time-series analysis
6. **Indexes**: Created for performance optimization
7. **Transactions**: Used in order processing, inventory updates

## Development Approach
1. Define database schema with proper relations
2. Create comprehensive SQL queries for all operations
3. Implement API endpoints with raw SQL
4. Add authentication and authorization
5. Implement error handling and validation
6. Optimize queries for performance

-- tables.sql: Database schema for e-commerce application
-- Enable UUID generation

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Users Table
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    email_verified BOOLEAN DEFAULT FALSE,
    address JSONB,  -- Structured address data
    role VARCHAR(20) CHECK (role IN ('customer', 'admin', 'seller')) DEFAULT 'customer',
    account_status VARCHAR(20) CHECK (account_status IN ('active', 'suspended', 'banned')) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE
);

CREATE TABLE user_tokens (
  token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL UNIQUE,
  type VARCHAR(50) NOT NULL CHECK (type IN ('email_verification', 'password_reset', 'api_token')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  used_at TIMESTAMP WITH TIME ZONE
);

-- 2. Categories Table
CREATE TABLE categories (
    category_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    parent_id UUID REFERENCES categories(category_id), -- Self-reference for hierarchical categories
    image_url VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 3. Products Table
CREATE TABLE products (
    product_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    sku VARCHAR(50) UNIQUE,
    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),
    compare_price DECIMAL(10, 2) CHECK (compare_price IS NULL OR compare_price >= price),
    cost_price DECIMAL(10, 2),
    category_id UUID REFERENCES categories(category_id),
    seller_id UUID REFERENCES users(user_id),
    brand VARCHAR(100),
    weight DECIMAL(8, 2),
    dimensions JSONB, -- Store height, width, length
    is_physical BOOLEAN DEFAULT TRUE, -- Physical vs digital product
    is_active BOOLEAN DEFAULT TRUE,
    is_featured BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 4. Product Images Table
CREATE TABLE product_images (
    image_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    url VARCHAR(255) NOT NULL,
    alt_text VARCHAR(255),
    is_primary BOOLEAN DEFAULT FALSE,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 5. Product Attributes Table
CREATE TABLE product_attributes (
    attribute_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    value TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 6. Inventory Table
CREATE TABLE inventory (
    inventory_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
    reserved_quantity INTEGER NOT NULL DEFAULT 0 CHECK (reserved_quantity >= 0),
    warehouse_location VARCHAR(100),
    low_stock_threshold INTEGER DEFAULT 5,
    last_restock_date TIMESTAMP WITH TIME ZONE,
    next_restock_date TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 7. Shopping Cart Table
CREATE TABLE shopping_carts (
    cart_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id) ON DELETE CASCADE,
    session_id VARCHAR(100), -- For non-logged in users
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE,
    
    -- Ensure either user_id or session_id is provided
    CONSTRAINT cart_user_or_session CHECK (
        (user_id IS NOT NULL AND session_id IS NULL) OR
        (user_id IS NULL AND session_id IS NOT NULL)
    )
);

-- 8. Cart Items Table
CREATE TABLE cart_items (
    cart_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cart_id UUID NOT NULL REFERENCES shopping_carts(cart_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    custom_attributes JSONB -- Store custom options, gift messages, etc.
);

-- 9. Orders Table
CREATE TABLE orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(user_id),
    order_number VARCHAR(50) UNIQUE NOT NULL,
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'processing', 'on_hold',
            'completed', 'cancelled', 'refunded',
            'failed', 'shipped', 'delivered'
        )
    ) DEFAULT 'pending',
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    shipping_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (shipping_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),
    shipping_address JSONB NOT NULL,
    billing_address JSONB NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    payment_status VARCHAR(30) CHECK (
        payment_status IN (
            'pending', 'authorized', 'paid',
            'partially_refunded', 'refunded', 'failed'
        )
    ) DEFAULT 'pending',
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- 10. Order Items Table
CREATE TABLE order_items (
    order_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id),
    name VARCHAR(255) NOT NULL, -- Store product name at time of purchase
    sku VARCHAR(50) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10, 2) NOT NULL CHECK (unit_price >= 0),
    subtotal DECIMAL(10, 2) NOT NULL CHECK (subtotal >= 0),
    tax_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (tax_amount >= 0),
    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
    total DECIMAL(10, 2) NOT NULL CHECK (total >= 0),
    product_data JSONB, -- Store snapshot of product data
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 11. Payments Table
CREATE TABLE payments (
    payment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id),
    amount DECIMAL(10, 2) NOT NULL CHECK (amount >= 0),
    payment_method VARCHAR(50) NOT NULL,
    payment_provider VARCHAR(50) NOT NULL,
    transaction_id VARCHAR(255),
    status VARCHAR(30) CHECK (
        status IN (
            'pending', 'authorized', 'completed',
            'failed', 'refunded', 'partially_refunded'
        )
    ) DEFAULT 'pending',
    provider_response JSONB, -- Store provider's response
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 12. Order History Table
CREATE TABLE order_history (
    history_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    order_id UUID NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    status VARCHAR(30) NOT NULL,
    comment TEXT,
    created_by UUID REFERENCES users(user_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 13. Product Reviews Table
CREATE TABLE product_reviews (
    review_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(user_id),
    rating INTEGER NOT NULL CHECK (rating BETWEEN 1 AND 5),
    title VARCHAR(255),
    content TEXT,
    is_verified_purchase BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) CHECK (status IN ('pending', 'approved', 'rejected')) DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 14. Wishlist Table
CREATE TABLE wishlists (
    wishlist_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    name VARCHAR(100) DEFAULT 'Default',
    is_public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 15. Wishlist Items Table
CREATE TABLE wishlist_items (
    wishlist_item_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    wishlist_id UUID NOT NULL REFERENCES wishlists(wishlist_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    added_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    notes TEXT
);

-- 16. Discounts Table
CREATE TABLE discounts (
    discount_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE,
    type VARCHAR(20) CHECK (type IN ('percentage', 'fixed_amount', 'free_shipping')) NOT NULL,
    value DECIMAL(10, 2) CHECK (value >= 0),
    min_purchase_amount DECIMAL(10, 2) CHECK (min_purchase_amount >= 0),
    max_discount_amount DECIMAL(10, 2) CHECK (max_discount_amount >= 0),
    starts_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ends_at TIMESTAMP WITH TIME ZONE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    usage_limit INTEGER,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 17. Discount Products Table (which products the discount applies to)
CREATE TABLE discount_products (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, product_id)
);

-- 18. Discount Categories Table (which categories the discount applies to)
CREATE TABLE discount_categories (
    discount_id UUID NOT NULL REFERENCES discounts(discount_id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(category_id) ON DELETE CASCADE,
    PRIMARY KEY (discount_id, category_id)
);

-- 19. User Addresses Table
CREATE TABLE user_addresses (
    address_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    is_default BOOLEAN DEFAULT FALSE,
    address_type VARCHAR(20) CHECK (address_type IN ('billing', 'shipping', 'both')) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    address_line1 VARCHAR(255) NOT NULL,
    address_line2 VARCHAR(255),
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 20. Notification Templates Table
CREATE TABLE notification_templates (
    template_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL UNIQUE,
    subject VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(50) CHECK (type IN ('email', 'sms', 'push')) NOT NULL,
    variables JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 21. User Notifications Table
CREATE TABLE user_notifications (
    notification_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(template_id),
    data JSONB, -- Data used to fill template variables
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP WITH TIME ZONE
);

-- 22. API tokens for developers
CREATE TABLE api_tokens (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    token VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    permissions JSONB,
    last_used_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 23. Product Tags Table
CREATE TABLE tags (
    tag_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) NOT NULL UNIQUE,
    slug VARCHAR(50) NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 24. Product-Tag Relation Table
CREATE TABLE product_tags (
    product_id UUID NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(tag_id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, tag_id)
);


-- indexes.sql: Optimized indexes for e-commerce database

-- Users Table Indexes
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_account_status ON users(account_status);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Categories Table Indexes
CREATE INDEX idx_categories_parent_id ON categories(parent_id);
CREATE INDEX idx_categories_is_active ON categories(is_active);

-- Products Table Indexes
CREATE INDEX idx_products_name ON products(name);
CREATE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_products_category_id ON products(category_id);
CREATE INDEX idx_products_seller_id ON products(seller_id);
CREATE INDEX idx_products_is_active ON products(is_active);
CREATE INDEX idx_products_is_featured ON products(is_featured);
CREATE INDEX idx_products_price ON products(price);
CREATE INDEX idx_products_created_at ON products(created_at);
-- This index helps with price range searches, a common filter in e-commerce
CREATE INDEX idx_products_price_active_category ON products(price, is_active, category_id);

-- Product Images Table Indexes
CREATE INDEX idx_product_images_product_id ON product_images(product_id);
CREATE INDEX idx_product_images_is_primary ON product_images(is_primary);




// server/src/config/db.js DONE

// server/src/config/environment.js   DONE

// server/src/utils/logger.js DONE

// server/src/utils/sqlBuilder.js  DONE
/**
 * SQL Query Builder
 * Provides utilities for dynamically building SQL queries
 */
class SqlBuilder {
  /**
   * Create a WHERE clause from filter conditions
   * @param {Object} filters - Key-value pairs of filter conditions
   * @param {number} [startParamIndex=1] - Starting index for parameterized queries
   * @returns {Object} Object containing where clause and parameters
   */
  static buildWhereClause(filters, startParamIndex = 1) {
    if (!filters || Object.keys(filters).length === 0) {
      return { whereClause: '', params: [] };
    }

    const conditions = [];
    const params = [];
    let paramIndex = startParamIndex;

    for (const [key, value] of Object.entries(filters)) {
      // Skip null or undefined values
      if (value === null || value === undefined) continue;

      // Handle special operators like IN, BETWEEN, etc.
      if (typeof value === 'object' && !Array.isArray(value)) {
        const { operator, value: operatorValue } = value;
        
        if (operator && operatorValue !== null && operatorValue !== undefined) {
          switch (operator.toUpperCase()) {
            case 'IN':
              if (Array.isArray(operatorValue) && operatorValue.length > 0) {
                const placeholders = operatorValue.map(() => `$${paramIndex++}`).join(', ');
                conditions.push(`${key} IN (${placeholders})`);
                params.push(...operatorValue);
              }
              break;
            case 'BETWEEN':
              if (Array.isArray(operatorValue) && operatorValue.length === 2) {
                conditions.push(`${key} BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
                params.push(operatorValue[0], operatorValue[1]);
                paramIndex += 2;
              }
              break;
            case 'LIKE':
            case 'ILIKE':
              conditions.push(`${key} ${operator} $${paramIndex++}`);
              params.push(`%${operatorValue}%`);
              break;
            case '>':
            case '>=':
            case '<':
            case '<=':
            case '!=':
              conditions.push(`${key} ${operator} $${paramIndex++}`);
              params.push(operatorValue);
              break;
            case 'IS NULL':
              conditions.push(`${key} IS NULL`);
              break;
            case 'IS NOT NULL':
              conditions.push(`${key} IS NOT NULL`);
              break;
            default:
              conditions.push(`${key} = $${paramIndex++}`);
              params.push(operatorValue);
          }
        }
      } else if (Array.isArray(value)) {
        // Handle array values as IN conditions
        if (value.length > 0) {
          const placeholders = value.map(() => `$${paramIndex++}`).join(', ');
          conditions.push(`${key} IN (${placeholders})`);
          params.push(...value);
        }
      } else {
        // Handle simple equality
        conditions.push(`${key} = $${paramIndex++}`);
        params.push(value);
      }
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    return { whereClause, params };
  }

  /**
   * Build ORDER BY clause from sort parameters
   * @param {Object|Array|string} sort - Sort configuration
   * @param {string} defaultSort - Default sort field and direction
   * @returns {string} ORDER BY clause
   */
  static buildOrderByClause(sort, defaultSort = 'created_at DESC') {
    if (!sort) {
      return `ORDER BY ${defaultSort}`;
    }

    let sortFields = [];

    if (typeof sort === 'string') {
      // Simple string sorting e.g. 'price ASC'
      sortFields.push(sort);
    } else if (Array.isArray(sort)) {
      // Array of sort fields e.g. ['price ASC', 'name DESC']
      sortFields = sort;
    } else if (typeof sort === 'object') {
      // Object with field:direction pairs e.g. { price: 'ASC', name: 'DESC' }
      sortFields = Object.entries(sort).map(([field, direction]) => 
        `${field} ${direction.toUpperCase()}`
      );
    }

    return sortFields.length > 0
      ? `ORDER BY ${sortFields.join(', ')}`
      : `ORDER BY ${defaultSort}`;
  }

  /**
   * Build LIMIT and OFFSET clause for pagination
   * @param {number} page - Page number (1-based indexing)
   * @param {number} limit - Number of records per page
   * @returns {Object} Object containing limit, offset and pagination info
   */
  static buildPaginationClause(page = 1, limit = 20) {
    const pageNum = Math.max(1, parseInt(page, 10));
    const limitNum = Math.max(1, parseInt(limit, 10));
    const offset = (pageNum - 1) * limitNum;

    return {
      limitClause: `LIMIT ${limitNum} OFFSET ${offset}`,
      limit: limitNum,
      offset,
      page: pageNum
    };
  }

  /**
   * Build INSERT query
   * @param {string} table - Table name
   * @param {Object} data - Data to insert
   * @returns {Object} SQL query and parameters
   */
  static buildInsertQuery(table, data) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const placeholders = columns.map((_, index) => `$${index + 1}`).join(', ');
    
    const query = `
      INSERT INTO ${table} (${columns.join(', ')})
      VALUES (${placeholders})
      RETURNING *
    `;
    
    return { query, values };
  }

  /**
   * Build UPDATE query
   * @param {string} table - Table name
   * @param {Object} data - Data to update
   * @param {Object} where - Where conditions
   * @returns {Object} SQL query and parameters
   */
  static buildUpdateQuery(table, data, where) {
    const columns = Object.keys(data);
    const values = Object.values(data);
    
    const setClause = columns
      .map((col, index) => `${col} = $${index + 1}`)
      .join(', ');
    
    let paramCount = values.length;
    const whereConditions = [];
    const whereValues = [];
    
    for (const [key, value] of Object.entries(where)) {
      whereConditions.push(`${key} = $${++paramCount}`);
      whereValues.push(value);
    }
    
    const query = `
      UPDATE ${table}
      SET ${setClause}
      WHERE ${whereConditions.join(' AND ')}
      RETURNING *
    `;
    
    return { query, values: [...values, ...whereValues] };
  }

  /**
   * Build a SELECT query
   * @param {string} table - Table name
   * @param {Array} columns - Columns to select
   * @param {Object} filters - Filter conditions
   * @param {Object} options - Additional options (sort, pagination)
   * @returns {Object} SQL query and parameters
   */
  static buildSelectQuery(table, columns = ['*'], filters = {}, options = {}) {
    const columnsStr = Array.isArray(columns) ? columns.join(', ') : columns;
    const { whereClause, params } = this.buildWhereClause(filters);
    
    const orderBy = options.sort
      ? this.buildOrderByClause(options.sort)
      : '';
    
    const pagination = options.pagination
      ? this.buildPaginationClause(options.pagination.page, options.pagination.limit)
      : { limitClause: '' };
    
    const query = `
      SELECT ${columnsStr}
      FROM ${table}
      ${whereClause}
      ${orderBy}
      ${pagination.limitClause}
    `;
    
    return { 
      query, 
      params, 
      pagination: options.pagination ? pagination : null 
    };
  }

  /**
   * Build a query for fetching total count (for pagination)
   * @param {string} table - Table name
   * @param {Object} filters - Filter conditions
   * @returns {Object} SQL query and parameters
   */
  static buildCountQuery(table, filters = {}) {
    const { whereClause, params } = this.buildWhereClause(filters);
    
    const query = `
      SELECT COUNT(*) AS total
      FROM ${table}
      ${whereClause}
    `;
    
    return { query, params };
  }

  /**
   * Generate a dynamically parameterized IN clause
   * @param {Array} items - Array of items for the IN clause
   * @param {number} startIndex - Starting parameter index
   * @returns {Object} parameterized IN clause and updated index
   */
  static generateInClause(items, startIndex = 1) {
    if (!items || items.length === 0) {
      return { inClause: '(NULL)', params: [], nextIndex: startIndex };
    }

    const placeholders = [];
    const params = [];
    let paramIndex = startIndex;

    for (const item of items) {
      placeholders.push(`$${paramIndex++}`);
      params.push(item);
    }

    return {
      inClause: `(${placeholders.join(', ')})`,
      params,
      nextIndex: paramIndex
    };
  }

  /**
   * Generate a dynamically parameterized VALUES clause for multi-row insert
   * @param {Array} items - Array of objects to insert
   * @param {Array} columns - Column names
   * @returns {Object} parameterized VALUES clause and parameters
   */
  static generateBulkInsertClause(items, columns) {
    if (!items || items.length === 0 || !columns || columns.length === 0) {
      return { valuesClause: '', params: [] };
    }

    const params = [];
    let paramIndex = 1;
    const valueRows = [];

    for (const item of items) {
      const rowPlaceholders = [];
      for (const column of columns) {
        rowPlaceholders.push(`$${paramIndex++}`);
        params.push(item[column] ?? null);
      }
      valueRows.push(`(${rowPlaceholders.join(', ')})`);
    }

    return {
      valuesClause: valueRows.join(',\n'),
      params
    };
  }

  /**
   * Build JSON/JSONB query conditions
   * @param {string} column - JSON column name
   * @param {string} path - JSON path
   * @param {*} value - Value to compare against
   * @param {string} [operator='='] - Comparison operator
   * @returns {Object} SQL fragment and value
   */
  static jsonCondition(column, path, value, operator = '=') {
    // For PostgreSQL JSONB operations
    const pathParts = path.split('.');
    let sqlFragment;
    
    if (pathParts.length === 1) {
      // Simple key access
      sqlFragment = `${column}->>'${pathParts[0]}' ${operator} $%i`;
    } else {
      // Nested key access
      const lastKey = pathParts.pop();
      const jsonPath = pathParts.map(part => `'${part}'`).join('->');
      sqlFragment = `${column}->${jsonPath}->>'${lastKey}' ${operator} $%i`;
    }
    
    return { sqlFragment, value };
  }
}

module.exports = SqlBuilder;



// server/src/utils/error.js DONE
/**
 * Custom error classes for the application
 */

/**
 * Base application error
 */
 snippet
class AppError extends Error {
  constructor(message, statusCode = 500, errorCode = 'INTERNAL_ERROR') {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.isOperational = true; // Operational errors are expected and can be handled gracefully
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = {
  AppError,
  DatabaseError,
  NotFoundError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  ConflictError,
  RateLimitError,
  BadRequestError,
  ExternalServiceError,
  formatError
};


// server/src/db/queries/products.js
const db = require('../../config/db');
const SqlBuilder = require('../../utils/sqlBuilder');
const logger = require('../../utils/logger');
const { NotFoundError, DatabaseError } = require('../../utils/error');

/**
 * Product Queries
 */
const productQueries = {


  /**
   * Get trending products based on views, orders, and ratings
   * @param {Object} options - Filter options and limits
   * @returns {Promise<Array>} Trending products
   */
  getTrendingProducts: async ({ timeframe = '7 days', categoryId = null, limit = 10 }) => {
    try {
      const params = [timeframe];
      let categoryFilter = '';
      
      if (categoryId) {
        categoryFilter = 'AND p.category_id = $2';
        params.push(categoryId);
      }
      
      params.push(limit);
      
      const query = `
        WITH recent_orders AS (
          SELECT 
            oi.product_id,
            COUNT(*) AS order_count,
            SUM(oi.quantity) AS total_quantity_ordered
          FROM 
            order_items oi
          JOIN 
            orders o ON oi.order_id = o.order_id
          WHERE 
            o.created_at >= NOW() - $1::INTERVAL
            AND o.status NOT IN ('cancelled', 'refunded', 'failed')
          GROUP BY 
            oi.product_id
        ),
        recent_reviews AS (
          SELECT 
            product_id,
            COUNT(*) AS review_count,
            AVG(rating) AS avg_recent_rating
          FROM 
            product_reviews
          WHERE 
            created_at >= NOW() - $1::INTERVAL
            AND status = 'approved'
          GROUP BY 
            product_id
        ),
        trending_score AS (
          SELECT 
            p.product_id,
            p.name,
            p.price,
            p.brand,
            c.name AS category_name,
            (
              SELECT url 
              FROM product_images 
              WHERE product_id = p.product_id AND is_primary = TRUE 
              LIMIT 1
            ) AS primary_image,
            COALESCE(ro.order_count, 0) * 10 +
            COALESCE(ro.total_quantity_ordered, 0) * 2 +
            COALESCE(rr.review_count, 0) * 5 +
            COALESCE(rr.avg_recent_rating, 0) * 3 AS trend_score
          FROM 
            products p
          LEFT JOIN 
            recent_orders ro ON p.product_id = ro.product_id
          LEFT JOIN 
            recent_reviews rr ON p.product_id = rr.product_id
          LEFT JOIN
            categories c ON p.category_id = c.category_id
          WHERE 
            p.is_active = TRUE
            ${categoryFilter}
        )
        SELECT * FROM trending_score
        WHERE trend_score > 0
        ORDER BY trend_score DESC, name
        LIMIT $${params.length}
      `;
      
      const result = await db.query(query, params);
      return result.rows;
    } catch (error) {
      logger.error('Error fetching trending products', { error: error.message });
      throw new DatabaseError('Failed to fetch trending products');
    }
  },
}

/**
 * Product Controller
 * Handles all product-related operations
 */
const productQueries = require('../db/queries/products');
const searchQueries = require('../db/queries/search');
const { NotFoundError, ValidationError } = require('../utils/error');
const logger = require('../utils/logger');

/**
 * Get a list of products with pagination and filtering
 */
exports.listProducts = async (req, res, next) => {}




/**
 * Validation Middleware
 * Provides request validation using Joi
 */
const Joi = require('joi');
const { ValidationError } = require('../utils/error');

/**
 * Validate request body, query parameters, or URL parameters
 * @param {Object} schema - Joi validation schema
 * @param {string} source - Request property to validate ('body', 'query', 'params')
 * @returns {Function} Express middleware
 */
exports.validate = (schema, source = 'body') => {
  return (req, res, next) => {
    const data = req[source];
    const { error, value } = schema.validate(data, {
      abortEarly: false,
      stripUnknown: true,
      errors: { wrap: { label: false } }
    });
    
    if (error) {
      const errorDetails = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }));
      
      return next(new ValidationError('Validation failed', 400, 'VALIDATION_ERROR', errorDetails));
    }
    
    // Replace the request data with the validated value
    req[source] = value;
    next();
  };
};

/**
 * Common validation schemas
 */
exports.schemas = {
  // User validation schemas
  user: {
    create: Joi.object({
      username: Joi.string().alphanum().min(3).max(50).required(),
      email: Joi.string().email().required(),
      password: Joi.string().min(8).required(),
      first_name: Joi.string().max(50),
      last_name: Joi.string().max(50),
      phone: Joi.string().max(20),
      address: Joi.object({
        address_line1: Joi.string().required(),
        address_line2: Joi.string().allow('', null),
        city: Joi.string().required(),
        state: Joi.string().allow('', null),
        postal_code: Joi.string().required(),
        country: Joi.string().required()
      }),
      role: Joi.string().valid('customer', 'admin', 'seller').default('customer')
    }),
    }
}
exports.createUser = exports.validate(exports.schemas.user.create);





/**
 * Order Controller
 * Handles order-related requests and processing
 */
const orderQueries = require('../db/queries/orders');
const productQueries = require('../db/queries/products');
const inventoryQueries = require('../db/queries/inventory');
const { BadRequestError, NotFoundError, ConflictError, AuthorizationError } = require('../utils/error');
const logger = require('../utils/logger');
const { v4: uuidv4 } = require('uuid');
const { generateOrderNumber } = require('../utils/orderHelpers');
const { createCsvStringifier } = require('csv-writer');

/**
 * Get all orders (admin/seller)
 */
exports.getAllOrders = async (req, res, next) => {
  try {
    const {
      page = 1,
      limit = 20,
      status,
      fromDate,
      toDate,
      customerId,
      minAmount,
      maxAmount,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;
    
    // Convert string values to appropriate types
    const options = {
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      status,
      fromDate: fromDate ? new Date(fromDate) : undefined,
      toDate: toDate ? new Date(toDate) : undefined,
      customerId,
      minAmount: minAmount ? parseFloat(minAmount) : undefined,
      maxAmount: maxAmount ? parseFloat(maxAmount) : undefined,
      sortBy,
      sortOrder: sortOrder.toUpperCase()
    };
    
    const result = await orderQueries.getAllOrders(options);
    
    res.status(200).json({
      success: true,
      data: result.orders,
      pagination: result.pagination
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get orders for authenticated user
 */
exports.getMyOrders = async (req, res, next) => {
  try {
    const userId = req.user.user_id;
    const {
      page = 1,
      limit = 10,
      status,
      fromDate,
      toDate,
      sortBy = 'created_at',
      sortOrder = 'DESC'
    } = req.query;
    
    // Convert string values to appropriate types
    const options = {
      page: parseInt(page, 10),
      limit: parseInt(limit, 10),
      status,
      fromDate: fromDate ? new Date(fromDate) : undefined,
      toDate: toDate ? new Date(toDate) : undefined,
      sortBy,
      sortOrder: sortOrder.toUpperCase()
    };
    
    const result = await orderQueries.getOrdersByUser(userId, options);
    
    res    CONTINUE
  }

}